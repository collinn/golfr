---
title: "Group Assignment"
author: "Hannah Kim"
date: "2024-05-28"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Generate Random Data
```{r}
# GenerateData function moved to separate .R file
```


# Assign Students to Groups

```{r}
# MakeGroups function moved to separate .R file
```

```{r}
# testoverlap function moved to separate .R file
```

## Matrix (Initial)
```{r}
# Function to initialize the student interaction matrix
## -99 can be replaced with -(n-1) when n = number of rows (students)
initMat <- function(students) {
  n <- length(students)
  initMat <- matrix(0, nrow = n, ncol = n, dimnames = list(students, students))
  diag(initMat) <- -99
  return(InitMat)
}

test <- initMat(student_data$Student)
test

```

# Group Assignment to Matrix

```{r}
# Function to update the interaction matrix based on group assignments
UpdateMat <- function(InitMat, groupAssignments, students) {
  numGroups <- length(unique(groupAssignments))
  
  for (g in seq_len(numGroups)) {
    groupMembers <- students[groupAssignments == g,]
    for (j in seq_along(groupMembers)) {
      for (k in seq_along(groupMembers)) {
        if (j != k) {
          InitMat[groupMembers[j], groupMembers[k]] <- 1
        }
      }
    }
  }
  
  return(InitMat)
}

UpdateMat(test, c(1L, 1L, 1L, 2L, 2L, 2L, 3L, 3L, 3L, 4L, 4L, 4L, 4L), student_data)

```

# Matrix to Group Assignment
```{r}
# ## Intermat in loop should be matrix of assignments
# 
# # Function to assign groups again based on the updated interaction matrix
# MatmakeGroups <- function(Intermat, studentsPerGroup) {
#   students <- rownames(Intermat)
#   numStudents <- length(students)
#   
#   # Check if the matrix is already full of 1s (except diagonal)
#   if (all(Intermat[Intermat != -99] == 1)) {
#     stop("All possible unique group combinations have been used.")
#   }
#   
#   # Initialize variables
#   numGroups <- ceiling(numStudents / studentsPerGroup)
#   groupAssignments <- rep(NA, numStudents)
#   
#   for (g in seq_len(numGroups)) {
#     # Find available students for the current group
#     availableStudents <- students[is.na(groupAssignments)]
#     
#     # Find the student with the fewest current pairings
#     minPairings <- apply(Intermat[availableStudents, availableStudents], 1, sum)
#     firstStudent <- availableStudents[which.min(minPairings)]
#     
#     # Initialize group with the first student
#     currentGroup <- firstStudent
#     groupAssignments[which(students == firstStudent)] <- g
#     
#     while (length(currentGroup) < studentsPerGroup && length(currentGroup) < length(availableStudents)) {
#       # Find the next student with the fewest pairings to the current group
#       pairSums <- colSums(Intermat[currentGroup, availableStudents, drop = FALSE])
#       nextStudent <- availableStudents[which.min(pairSums)]
#       
#       # Add the next student to the current group
#       currentGroup <- c(currentGroup, nextStudent)
#       groupAssignments[which(students == nextStudent)] <- g
#     }
#   }
#   
#   # Assign remaining students to existing groups if any
#   remainingStudents <- students[is.na(groupAssignments)]
#   if (length(remainingStudents) > 0) {
#     for (student in remainingStudents) {
#       groupCounts <- table(groupAssignments, useNA = "no")
#       smallestGroup <- as.integer(names(groupCounts)[which.min(groupCounts)])
#       groupAssignments[which(students == student)] <- smallestGroup
#     }
#   }
#   
#   return(groupAssignments)
# }
# 
# # Example Usage
# 
# nStudents <- 13
# studentData <- GenerateData(nStudents)
# studentsPerGroup <- 3
# iterations <- 2
# Intermat <- InitMat(student_data$Student)
# 
# result <- MatmakeGroups(Intermat, studentsPerGroup)
# 
# # Print results
# print(result$combinedData)
# print(result$interactionMatrix)
# 
# # Assign groups again based on the updated matrix
# newGroupAssignments <- AssignGroupsAgain(result$interactionMatrix, studentsPerGroup)
# print(newGroupAssignments)
```

```{r}

```

