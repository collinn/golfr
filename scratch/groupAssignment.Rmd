---
title: "Group Assignment"
author: "Hannah Kim"
date: "2024-05-28"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Generate Random Data
```{r}
# GenerateData function moved to separate .R file
```


# Assign Students to Groups

```{r}
# MakeGroups function moved to separate .R file
```

```{r}
# testoverlap function moved to separate .R file
```

## Matrix (Initial)
```{r}
# initmat function moved to separate .R file
```

# Group Assignment to Matrix

```{r}
# updatemat function moved to separate .R file
```

```{r}
# # Function to check for remaining 'r-1' values and assign groups if necessary
# testmat <- function(initialmat, student_data, students_per_group, iterations) {
#   num_students <- nrow(initialmat)
#   
#   for (r in seq_len(iterations)) {
#     # Check each row for remaining 'r-1' values
#     for (i in seq_len(num_students)) {
#       if (any(initialmat[i, ] == (r-1))) {
#         # If found, proceed to assign groups for this iteration
#         new_groups <- MakeGroups(student_data, students_per_group, 1)
#         initialmat <- updatemat(initialmat, new_groups$Round_1, student_data$Student)
#       } else {
#         # If no remaining 'r-1' values, pass
#         next
#       }
#     }
#   }
#   
#   return(initialmat)
# }
# 
# 
n_students <- 9
student_data <- GenerateData(n_students)
students_per_group <- 3
iterations <- 3
M <- initmat(student_data$Student)
grouped_data <- MakeGroups(student_data, students_per_group, 
                           iterations, M)


updated_matrix <- updatemat(M, grouped_data$Round_1, student_data$Student)

updated_matrix
```

```{r}
# groupassign function moved to separate .R file
```

```{r warning = F}
library(dplyr)

# Function to update group assignment to weight matrix

updatemat <- function(file_path, round) {
  
    data <- read.csv(file_path, stringsAsFactors = FALSE)
  
  # Extract student names
  students <- data[[1]]
  
  # Initialize the weight matrix
  n <- length(students)
  weight_matrix <- matrix(0, nrow = n, ncol = n)
  colnames(weight_matrix) <- students
  rownames(weight_matrix) <- students
  
  # Set diagonal elements to -99
  diag(weight_matrix) <- -99
  
  # Get group assignments for round 1
  round_col <- data[[round + 1]] 
  
  # Update the weight matrix based on round 1 group assignments
  for (group in unique(round1_groups)) {
    group_members <- which(round_col == group)
    for (i in group_members) {
      for (j in group_members) {
        if (i != j) {
          weight_matrix[i, j] <- 1
        }
      }
    }
  }
  
  return(weight_matrix)
}

# Example usage
file_path <- "C:/Users/hanna/Downloads/golfer_solution.csv"
round <- 5
weight_matrix <- updatemat(file_path, round)

```

```{r}
# Function to calculate conflict scores
conflict <- function(round, weights) {
  # Helper function to iterate over all unique pairs within a group
  forEachPair <- function(group, func) {
    n <- length(group)
    for (i in 1:(n-1)) {
      for (j in (i+1):n) {
        func(group[i], group[j])
      }
    }
  }
  
  # Initialize group scores
  groupScores <- vector("list", length(round))
  
  # Calculate the group conflict score
  for (g in seq_along(round)) {
    group <- round[[g]]
    groupCost <- 0
    forEachPair(group, function(a, b) {
      groupCost <- groupCost + weights[a, b]^2
    })
    groupScores[[g]] <- groupCost
  }
  
  # Calculate the total conflict score
  totalConflictScore <- sum(unlist(groupScores))
  
  # Return the result
  result <- list(
    groups = round,
    groupScores = groupScores,
    total = totalConflictScore
  )
  
  return(result)
}

conflict_score <- conflict(round, weight_matrix)
print(conflict_score)
```

