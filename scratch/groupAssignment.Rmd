fd---
title: "Group Assignment"
author: "Hannah Kim"
date: "2024-05-28"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Generate Random Data
```{r}
# GenerateData function moved to separate .R file
```


# Assign Students to Groups

```{r}
# MakeGroups function moved to separate .R file
```

```{r}
# testoverlap function moved to separate .R file
```

## Matrix (Initial)
```{r}
# initmat function moved to separate .R file
```

# Group Assignment to Matrix

```{r}
# updatemat function moved to separate .R file
```

```{r}
# # Function to check for remaining 'r-1' values and assign groups if necessary
# testmat <- function(initialmat, student_data, students_per_group, iterations) {
#   num_students <- nrow(initialmat)
#   
#   for (r in seq_len(iterations)) {
#     # Check each row for remaining 'r-1' values
#     for (i in seq_len(num_students)) {
#       if (any(initialmat[i, ] == (r-1))) {
#         # If found, proceed to assign groups for this iteration
#         new_groups <- MakeGroups(student_data, students_per_group, 1)
#         initialmat <- updatemat(initialmat, new_groups$Round_1, student_data$Student)
#       } else {
#         # If no remaining 'r-1' values, pass
#         next
#       }
#     }
#   }
#   
#   return(initialmat)
# }
# 
# 
# n_students <- 9
# student_data <- GenerateData(n_students)
# students_per_group <- 3
# iterations <- 3
# M <- initmat(student_data$Student)
# grouped_data <- MakeGroups(student_data, students_per_group, 
#                            iterations, M)
# 
# 
# updated_matrix <- updatemat(M, grouped_data$Round_1, student_data$Student)
# 
# updated_matrix
```

```{r}
# groupassign function moved to separate .R file
```

```{r message = F}
library(dplyr)
df <- read.csv("../data/golfer_solution (3).csv")
# Function to make individual round matrices and combine them
roundmat <- function(df) {
  students <- df[[1]]
  rounds <- ncol(df)-1
  n <- length(students)
  weight_list <- vector("list", length = rounds)
  
  # Step 1: Generate individual round matrices
  for (round in 1:rounds) {
    weight_matrix <- matrix(0, nrow = n, ncol = n, dimnames = list(students, students))
    diag(weight_matrix) <- -99
    round_col <- df[[round + 1]]
    
    for (group in unique(round_col)) {
      ## This below creates weight for a particular group
      group_members <- which(round_col == group)
      for (i in seq_along(group_members)) {
        for (j in (i + 1):length(group_members)) {
          if (j > length(group_members)) break
          weight_matrix[group_members[i], group_members[j]] <- 1
          weight_matrix[group_members[j], group_members[i]] <- 1
        }
      }
    }

  # Step 2: Combine round matrices after all are made
    weight_list[[round]] <- weight_matrix
  }
  
  return(weight_list)
}

# Example usage:
weight_list <- roundmat(df)
print(weight_list)

# Cumulative Matrix
cummat <- Reduce(`+`, weight_list, accumulate = TRUE)

```

```{r}
# Function to calculate conflict score
Final <- function(weight_list) {
  n <- nrow(weight_list[[1]])
  initial_matrix <- matrix(0, nrow = n, ncol = n)
  diag(initial_matrix) <- -99
  
  cumulative_matrices <- list(initial_matrix)
  conflict_scores <- numeric(length(weight_list))
  
  for (round in seq_along(weight_list)) {
    cumulative_matrix <- cumulative_matrices[[round]] + weight_list[[round]]
    cumulative_matrices[[round + 1]] <- cumulative_matrix
    
    madePair <- weight_list[[round]][upper.tri(weight_list[[round]])]
    scores_from_previous <- cumulative_matrices[[round]][upper.tri(cumulative_matrices[[round]])]
    
    conflict_scores[round] <- sum(scores_from_previous[as.logical(madePair)]^2)
  }
  
  return(conflict_scores)
}

Final(weight_list)
```

```{r}
# Recreate GeneratePermutation from Java
generatePermutation <- function(groups, ofSize) {
  # Total number of players
  totalSize <- groups * ofSize
  
  firstGroupAssignment <- function() {
    shuffledPlayers <- sample(1:totalSize)  # Shuffle the players again
    split(shuffledPlayers, ceiling(seq_along(shuffledPlayers) / ofSize))  # Group the players
  }
  
  # Generate 10 candidate group assignments as potential second groupings
  candidates <- replicate(10, firstGroupAssignment(), simplify = FALSE)
  
  return(candidates)
}

candidates <- generatePermutation(4, 3)

```

```{r}
GenerateMutation <- function(candidates) {
   # Total number of players
  n <- length(unlist(candidates[[1]]))
  students <- as.character(1:n)# Create student labels as 1 to n
  
  # Initialize the weight list to store the weight matrices for all candidates
  weight_list <- vector("list", length = length(candidates))
  
  # Iterate over each candidate (i.e., each potential second group assignment)
  for (cand in seq_along(candidates)) {
    # Initialize a weight matrix for the current candidate
    weight_matrix <- matrix(0, nrow = n, ncol = n, dimnames = list(students, students))
    diag(weight_matrix) <- -99
    # Get the groups for the current candidate
    groups <- candidates[[cand]]
    
    # Iterate over each group in the candidate
    for (group in groups) {
      # Find the indices of the players in the group
      group_members <- unlist(group)
      
      # Update the weight matrix for the pairs within this group
      for (i in seq_along(group_members)) {
        for (j in (i + 1):length(group_members)) {
          if (j > length(group_members)) break
          weight_matrix[group_members[i], group_members[j]] <- 1
          weight_matrix[group_members[j], group_members[i]] <- 1
        }
      }
    }
    
    # Add the completed weight matrix to the list of weight matrices
    weight_list[[cand]] <- weight_matrix
  }
  
  return(weight_list)
}


candidates <- generatePermutation(4, 3)
mutation_weights <- GenerateMutation(candidates)

```

```{r}
Conflict <- function(round1_matrix, mutation_weights) {
  # Combine the first round matrix with each of the 10 candidate matrices for round 2
  combined_matrices <- lapply(mutation_weights, function(candidate_matrix) {
    # Calculate the cumulative matrix: round 1 + candidate matrix
    updated_matrix <- cumulative_matrix + candidate_matrix
    return(list(cumulative_matrix, updated_matrix))  # List of round 1 and cumulative matrix for each candidate
  })
  
  # Use the Final function to calculate the conflict score for each candidate
  conflict_scores <- lapply(combined_matrices, function(weight_list) {
    Final(weight_list)
  })
  
  return(conflict_scores)  # Returns conflict scores for all 10 candidates
}

round1_matrix <- roundmat(df)[[1]]
#round1_matrix <- roundmat(df)[1]

conflict_scores <- Conflict(round1_matrix, mutation_weights)

conflict_scores

```
