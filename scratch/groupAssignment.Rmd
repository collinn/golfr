---
title: "Group Assignment"
author: "Hannah Kim"
date: "2024-05-28"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Generate Random Data
```{r}
# GenerateData function moved to separate .R file
```


# Assign Students to Groups

```{r}
# MakeGroups function moved to separate .R file
```

```{r}
# testoverlap function moved to separate .R file
```

## Matrix (Initial)
```{r}
# initmat function moved to separate .R file
```

# Group Assignment to Matrix

```{r}
# updatemat function moved to separate .R file
```

```{r}
# # Function to check for remaining 'r-1' values and assign groups if necessary
# testmat <- function(initialmat, student_data, students_per_group, iterations) {
#   num_students <- nrow(initialmat)
#   
#   for (r in seq_len(iterations)) {
#     # Check each row for remaining 'r-1' values
#     for (i in seq_len(num_students)) {
#       if (any(initialmat[i, ] == (r-1))) {
#         # If found, proceed to assign groups for this iteration
#         new_groups <- MakeGroups(student_data, students_per_group, 1)
#         initialmat <- updatemat(initialmat, new_groups$Round_1, student_data$Student)
#       } else {
#         # If no remaining 'r-1' values, pass
#         next
#       }
#     }
#   }
#   
#   return(initialmat)
# }
# 
# 
# n_students <- 9
# student_data <- GenerateData(n_students)
# students_per_group <- 3
# iterations <- 3
# M <- initmat(student_data$Student)
# grouped_data <- MakeGroups(student_data, students_per_group, 
#                            iterations, M)
# 
# 
# updated_matrix <- updatemat(M, grouped_data$Round_1, student_data$Student)
# 
# updated_matrix
```

```{r}
# groupassign function moved to separate .R file
```

```{r warning = F}
library(dplyr)
# Function to generate cumulative matrix (weight matrix)
cummat <- function(df) {
  
  data <- read.csv(df)
  
  # Extract student names
  students <- data[[1]]
  
  # Initialize the weight matrix
  n <- length(students)
  weight_matrix <- matrix(0, nrow = n, ncol = n, dimnames = list(students, students))
  
  # Set diagonal to -99
  diag(weight_matrix) <- -99
  
  # Loop through each round and update the weight matrix
  for (round in 2:ncol(data)) { # Start from the second column to the last column
    round_col <- data[[round]]
    
    for (group in unique(round_col)) {
      group_members <- which(round_col == group)
      for (i in 1:length(group_members)) {
        for (j in (i + 1):length(group_members)) {
          if (i == j) next
          weight_matrix[group_members[i], group_members[j]] <- weight_matrix[group_members[i], group_members[j]] + 1
          weight_matrix[group_members[j], group_members[i]] <- weight_matrix[group_members[j], group_members[i]] + 1
        }
      }
    }
  }
  
  return(weight_matrix)
}

data <- "../data/golfer_solution (2).csv"
weight_matrix <- cummat(data)

```


```{r}
# Function to generate round matrix
roundmat <- function(data) {

  data <- read.csv(data)
  
  # Extract student names
  students <- data[[1]]
  
  # Initialize the weight matrix
  n <- length(students)
  weight_matrix <- matrix(0, nrow = n, ncol = n, dimnames = list(students, students))
  
  # Initialize a vector to store conflict scores for each round
  conflict_scores <- numeric(ncol(data) - 1)
  
  weight_list <- vector("list", length = ncol(data)-1)
  
  # Loop through each round, update the weight matrix, and calculate the conflict score
  for (round in 1:(ncol(data)-1)) { # Start from the second column to the last column
    round_col <- data[[round+1]]
    
    ## within each round, create new weight matrix
    weight_matrix <- matrix(0, nrow = n, ncol = n, dimnames = list(students, students))
    # Set diagonal to -99
    diag(weight_matrix) <- -99
    
    
    for (group in unique(round_col)) {
      
      group_members <- which(round_col == group)
      for (i in 1:length(group_members)) {
        for (j in (i + 1):length(group_members)) {
          if (i == j) next
          weight_matrix[group_members[i], group_members[j]] <- weight_matrix[group_members[i], group_members[j]] + 1
          weight_matrix[group_members[j], group_members[i]] <- weight_matrix[group_members[j], group_members[i]] + 1
        }
      }
    }
    
    weight_list[[round]] <- weight_matrix
    
  }
  
  return(weight_list)
  }

weight_list <- roundmat(data)
print(weight_list)

```

```{r}
# Function to calculate conflict scores
# conflict <- function(weight_matrix) {
#   n <- nrow(weight_matrix)
#   conflict_score <- 0
#   
#   ## Get upper tri entries
#   ww <- weight_matrix[upper.tri(weight_matrix)]
#   ww <- ww[ww > 0] # keep only positive entries
#   conflict_score <- sum((ww-1)^2)
#   
#   return(conflict_score)
# }
# 
# conflictscore <- conflict(weight_matrix)
# print(conflictscore)

```

```{r}
Final <- function (weight_list){
  wm <- Reduce(`+`, weight_list, accumulate = TRUE) # wm = cumulative weight matrix

#cs <- lapply(cumulativemat, conflict)

## Round 5 and round 4
wm5 <- wm[[5]] # magic number
wm4 <- wm[[4]] # magic number

## Subtracting shows which people were paired in round 5
weight5 <- wm5-wm4 # every entry with "1" was paired in round 5

## This is same as weight matrix for round 5!
identical(weight5, weight_list[[4]])

madePair <- weight5[upper.tri(weight5)] # index of pairs made

## Scores from round 4
scores_from_four <- wm4[upper.tri(wm4)]


## use 0/1 as logical to subset correct ones!
conflict_score <- sum(scores_from_four[as.logical(madePair)]^2)

return(conflict_score)
}

Final(weight_list)
```


```{r}
f <- function(df) {
  studnets <- df[[1]]
  round_weights <- vector("list", n)
  
  for (i in rounds) {
    round_weights[[i]] <- compute_round_weight(df[[i]])
  }
  return(round_weights)
}

f2 <- function(round_weights) {
  # 1: compute cumulative weights using Reduce
  # 2: use both of these to compute conflict scores
}
```

